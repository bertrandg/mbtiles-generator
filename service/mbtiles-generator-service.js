/*
 Copyright 2015 eBusiness Information
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
/**
 * Created by Lo√Øc Ortola on 16/10/2015.
 * MBTiles Generator service
 */
// Conf & Utils
var Conf = require('../conf/conf');
var ProjectionUtils = require('../util/projection-utils');
// Classes
var Tile = require('../model/tile');
var Step = require('step');
// Logging
var debug = require('debug')('mbt:service:mbtile-generator-service');
// Imports
var fs = require('fs');
var path = require('path');
var sqlite3 = require('sqlite3').verbose();
var http = require('http');
var uuid = require('node-uuid');
var mapper = getMapper(Conf.tileServer.type);
var mbTilesStatusService = require('./mbtiles-status-service');

// Number of requests for each step set.
var STEP_REQUEST_SIZE = 96;


/**
 * Get the appropriate mapper
 * @param type the tile server type
 */
function getMapper(type) {
  if (type === 'osm') {
    return require('../mapper/osm-mapper');
  } else if (type === 'bing') {
    return require('../mapper/bing-mapper');
  }
  throw new Error('Wrong tile mapper specified. Please specify an appropriate mapper type in Conf');
}

var initMBTilesRequest = function(proxy) {
  // Create temporary sqlite DB file
  var token = uuid.v4();
  var file = 'data/' + token + '.sqlite';
  var db = new sqlite3.Database(file);
  mbTilesStatusService.create(token);
  return {"db": db, "token": token, "file": file, "proxy": proxy};
};

/**
 * Returns the future token to retrieve MBTiles once ready.
 * @param bounds the MBTiles bounds
 * @param layer the requested layer
 * @returns a string value
 */
var requestMBTiles = function (bounds, layer, proxy) {
  var request = initMBTilesRequest(proxy);
  processMBTiles(request, bounds, layer);
  return request.token;
};

/**
 * Returns a promise whose resolution will return an mbtile with the requested bounds.
 * @param bounds
 * @param layer the requested layer
 * @returns {Promise} the MBTile
 */
var requestMBTilesSync = function (bounds, layer, proxy) {
  var request = initMBTilesRequest(proxy);
  return processMBTiles(request, bounds, layer);
};

/**
 * Returns a promise whose resolution will return an mbtile with the requested bounds.
 * @param request the mbtiles request
 * @param bounds
 * @param layer the requested layer
 * @returns {Promise} the MBTile bounds
 */
var processMBTiles = function (request, bounds, layer) {
  
  return new Promise(function (resolve, reject) {
    console.log("Processing MBTiles for bounds:" + JSON.stringify(bounds));
    
    fs.readFile('conf/schema.sql', 'utf8', function (err, data) {
      if (err) {
        console.error('Error while loading schema: ' + err);
        throw err;
      }
      createTables(request.db, data)
          .then(function () {
            // required MetaData for mbtiles spec
            var metaData = {
              "name": "Mapsquare MBTile",
              "type": "baselayer",
              "version": 1,
              "description": "Base Layer generated by Mapsquare",
              "format": "png",
              "bounds": bounds.left + ',' + bounds.bottom + ',' + bounds.right + ',' + bounds.top
            };

            if (layer) {
              metaData.type = "overlay";
            }
            // Insert metadata into db
            return insertMetadata(request.db, metaData);
            
          })
          .then(function () {
            // Fetch then store tiles
            return fetchAndStoreTiles(request.token, bounds, layer, request.proxy, request.db);
          })
          .then(function () {
            // All tiles have been stored. Close db.
            request.db.close(function () {
              console.log('MBTile computed successfully. File output is available in ' + request.file);
              // Persist tile state
              mbTilesStatusService.update(request.token, "done", 100);
              // Open file, send binary data to client, and remove file.
              fs.readFile(request.file, function (err, data) {
                resolve(data);
              });
            });

          })
    });
  });
};

/**
 * Create mbtiles tables
 * @param db the database
 * @param data the queries to execute
 * @returns {Promise}
 */
var createTables = function (db, data) {
  return new Promise(function (resolve, reject) {
    db.exec(data, function () {
      resolve();
    });
  });
};

/**
 * Insert metadata into mbtile
 * @param db the database
 * @param metaData the metadata object
 * @returns {Promise}
 */
var insertMetadata = function (db, metaData) {
  return new Promise(function (resolve, reject) {
    debug('Inserting Metadata');
    db.serialize(function () {
      var stmt = db.prepare('INSERT INTO metadata VALUES (?, ?)');
      for (var key in metaData) {
        stmt.run(key, metaData[key]);
      }
      stmt.finalize();
      debug('Metadata inserted successfully.');
    });
    resolve();
  });
};

/**
 * Insert a tile using an sqlite statement
 * @param stmt the statement
 * @param tile the tile metadata
 * @param data the tile blob
 * @param callback once it is done
 */
var insertTile = function (stmt, tile, data, callback) {
  debug('Inserting Tile');
  stmt.run(tile.z, tile.x, Math.pow(2, tile.z) - tile.y - 1, data);
  callback();
};

/**
 * Process step by step fetch of tiles and parallel store into db
 * @param token the generation token
 * @param bounds the requested bounds
 * @param layer the requested layer
 * @param db the database
 * @returns {Promise} a promise resolved when finished.
 */
var fetchAndStoreTiles = function (token, bounds, layer, proxy, db) {
  return new Promise(function (resolve, reject) {
    // List tiles
    var tiles = listTiles(bounds, layer);
    console.log(tiles.length + " tiles to process.");

    // Prepare steps
    var steps = [];
    var stepCount = Math.floor(1 + tiles.length / STEP_REQUEST_SIZE);
    for (var s = 0; s < stepCount; s++) {
      var stmt = db.prepare('INSERT INTO tiles VALUES (?, ?, ?, ?)');
      // Use closures to split the tile fetch into sets, to prevent overflows (10000s of http requests at the same time).
      steps.push(fetchTilesFunction(tiles.slice(s * STEP_REQUEST_SIZE, Math.min((s + 1) * STEP_REQUEST_SIZE, tiles.length)), stmt, proxy));
      steps.push(finalizeStepFunction(stmt, token, s, stepCount));
    }
    // Last step is resolution
    steps.push(function () {
      debug('Rendering done');
      resolve();
    });

    // Launch processing
    Step.apply(this, steps);

  });
};

/**
 * Make a list of the necessary tiles to compute and embed into the mbtile according to bounds.
 * @param bounds the requested bounds
 * @param layer the requested layer
 * @returns {Array} the array of tiles
 */
var listTiles = function (bounds, layer) {
  debug('Listing tiles for bounds' + JSON.stringify(bounds));
  var tiles = [];
  for (var z = Conf.minZoom; z <= Conf.maxZoom; z++) {
    var coords1 = ProjectionUtils.latLngToTileXYForZoom(bounds.top, bounds.left, z);
    var coords2 = ProjectionUtils.latLngToTileXYForZoom(bounds.bottom, bounds.right, z);
    // Adjust to process at least one tile for each zoom (lower zoom levels)
    if (coords1[0] === coords2[0]) {
      coords2[0] += 1;
    }
    if (coords1[1] === coords2[1]) {
      coords2[1] += 1;
    }

    for (var x = Math.min(coords1[0], coords2[0]); x <= Math.max(coords1[0], coords2[0]); x++) {
      for (var y = Math.min(coords1[1], coords2[1]); y <= Math.max(coords1[1], coords2[1]); y++) {
        var t = new Tile(x, y, z, layer, mapper.getExtension());
        tiles.push(t);
      }
    }
  }
  return tiles;

};

/**
 * Closure for tile fetch
 * @param tiles the set of tiles to fetch
 * @param stmt the statement to run queries in
 * @returns {Function} the function
 */
var fetchTilesFunction = function (tiles, stmt, proxy) {
  return function () {
    var group = this.group();
    tiles.forEach(function (t) {
      var next = group();
      fetchTile(t, proxy, 0, function (data) {
        // Once fetch is done, store tile
        insertTile(stmt, t, data, next);
      });
    });
  };

};

/**
 * Closure for step finalization
 * @param stmt the statement to close
 * @param token the current token
 * @param s the current step
 * @param stepCount the total number of steps 
 * @returns {Function} the function
 */
var finalizeStepFunction = function (stmt, token, s, stepCount) {
  return function () {
    mbTilesStatusService.update(token, "generating", Math.floor((s + 1) * 100 / (stepCount + 1)));
    stmt.finalize();
    this();
  }
};

/**
 * Make an http request to get a particular tile from the tileserver. Will attempt 3 times if request fails.
 * @param t the requested tile
 * @param attempts the number of failed attempts (< 3)
 * @param callback the callback once tile is fetched
 */
var fetchTile = function (t, proxy, attempts, callback) {
  var url = mapper.getTileUrl(t);

  if(proxy) {
    url = {
      host: proxy.host,
      port: proxy.port,
      path: url
    }
    debug("Getting " + url.path + " with proxy " + url.host + ":" + url.port);
  }
  else {
    debug("Getting " + url);
  }

  http.get(url, function (res) {
    if (res.statusCode == 200) {
      res.setEncoding('base64');
      var body = '';
      res.on('data', function (chunk) {
        body += chunk;
      });
      res.on('end', function () {
        var blob = new Buffer(body, 'base64');
        // Store tile in sqlite db
        callback(blob);
      })
    } else {
      var error = {statusCode: res.statusCode, message: res.body};
      console.error('Received error from server' + JSON.stringify(error));
      // Will retry 3 times if error occured (maybe tile is not ready yet), fail beyond.
      if (attempts < 3) {
        fetchTile(t, proxy, attempts++, callback);
      }
    }
  }).on('error', function (err) {
    console.error('Received error from server' + JSON.stringify(err));
    // Will retry 3 times if error occured (maybe tile is not ready yet), fail beyond.
    if (attempts < 3) {
      fetchTile(t, proxy, attempts++, callback);
    }
  });
};


/**
 * Retrieve MBTiles data for current token.
 * @param token
 */
var getMBTiles = function (token, callback) {
  var status = mbTilesStatusService.get(token);
  // Return if not finished
  if (!status || status.status === "generating") {
    callback();
    return;
  }
  
  var dbFile = 'data/' + token + '.sqlite';

  // Open file, send binary data to client.
  fs.readFile(dbFile, function (err, data) {
    callback(data);
    // Tile has been downloaded. Notify
    mbTilesStatusService.update(token, "downloaded", 100);
  });
};

/**
 * Remove all MBTiles which have no reference in the app or which have been downloaded already.
 */
var removeOldMBTiles = function () {
  fs.readdir('data', function (err, files) {
    for (var i in files) {
      var token = path.basename(files[i], '.sqlite');
      var status = mbTilesStatusService.get(token);
      if (!status || status.status === "downloaded") {
        fs.unlink('data/' + token + '.sqlite', function(err) {
          debug('Deleted file. Error? ' + err);
        });
      }
    }
    console.log('MBTiles Cleaning in progress.');
  });
};

// Init
fs.mkdir('data', function (err) {
  if (err && err.code != 'EEXIST') {
    console.error(err);
  }
});


// Exports
module.exports = {
  requestMBTilesSync: requestMBTilesSync,
  requestMBTiles: requestMBTiles,
  getMBTiles: getMBTiles,
  removeOldMBTiles: removeOldMBTiles
};